计算字符串长度-------------------------------------------------------------------------------
			char *p = " abcdefffz ";
			i=strlen(p)；	//strlen函数是用来计算字符串长度的，和size计算占用内存大小不一样，因为strlen只能计算字符串的地址，如果用其他整数的地址就会报错；

			打印的i输出的字符串个数是11，为什么不是9呢。因为空格也算字符串，
			
sizeof计算多维数组的长度------------------------------------------------------------------------------------------------------------------------------------------------

			char *key[]={"aaaaa","bbbbbbb","ccccccc"};//如果计算二维数组的长度
			int i=sizeof(key)/sizeof(*key);//计算多为数组长度
			int i=sizeof(key)/sizeof(key[0]);//计算多为数组长度,这两个是一样的。
			

检查字符串里面是否有空格------------------------------------------------------------------------
			#include<ctype.h>
			int isspace(int c)；//该函数检查c 里面的参数是否为空格，为空格的话返回TRUE，否则返回NULL；

			char *p = " abcdefffz ";
			isspace(p[0]);//运行后返回TRUE，因为字符串0地址是空格
			isspace(p[1]);//运行后返回NULL，因为字符串1地址不是空格


两头堵模型对上面的函数进行应用-------------------------------------------------------------------------------
			char *p = "  abcdefffz  ";
			求出除去空格后剩下字符串的长度，因为用strlen计算长度是要把空格计算进去的，所以我们现在是要去掉空格来计算字符串长度

			/*****************isspace函数应用*********************
			void main(){
			char *p = "    abcdefffz     ";
			int i,j,count;
			i = 0;
			j = strlen(p) - 1;
	
		
			while (isspace(p[i]) && p != '\0'){    //这句的意思就是p[i]这个位置等于空格返回真，同时p不等于\0，也就是没有到字符串尾巴，那么i++
				i++;
			}
			while (isspace(p[j]) && p != '\0'){
				j--;
			}
			count = j - i + 1;//这里加1是因为j-i比预计的少了一位，所以要+1
			printf("char number = %d\n", count);

			system("pause");
			}

			输出的结果是9，也就是除去空格后字符串长度
			************************************************/



字符串拷贝函数----------------------------------------------------------------------------------------
			#include<string.h>
			函数原型char *strncpy(char *dest,char *src,size_t n);//将src的内容复制到dest中，复制多少又n决定
			复制结束后不在末尾自动添加'\0'，也就是结果dest不包括'\0'，需要再手动添加一个'\0'。

			
			int main(){
			char name[]={"Chinanet"},dest[20]={};
			strncpy(dest,name,3);
			dest[3]='\0';//最后一位没添加\0，那么在printf的时候就会把剩下的17个内存单元打印完，就会出现17个乱码，因为你只复制了三个到dest
			printf("%s\n",dest); }



			/*************************strncpy函数应用************************************
			/*将空格忽略函数进行修改，将取出来的字符串拷贝进另外一个缓存*/
			int getcountchar(char *str,char *namestr){
			char *p = str;
			int i, j, ncount;
			i = 0;
			j = strlen(p) - 1;

			while (isspace(p[i]) && p != '\0'){
				i++;
			}
			while (isspace(p[j]) && p != '\0'){
				j--;
			}
			ncount = j - i + 1;
			strncpy(namestr, str + i,ncount);
			namestr[ncount] = '\0';//这个必须加否则后面的128个字节将全部打印出来
			return 0;

			}
			////////////////////////////////////////////////////////////
			main(){
			char *p = "   abcdefffz   ";
			char buf[128];
			getcountchar(p, buf);
			printf("%s\n", buf);
			}

			*************************************************************/

			/*************************************************************
			/*将一个内存的数据覆盖本内存现有的数据*/
			int getnospacechar(char *str){
			char *p = str;
			int i, j, ncount;
			i = 0;
			j = strlen(p) - 1;

			while (isspace(p[i]) && p != '\0'){
				i++;
			}
			while (isspace(p[j]) && p != '\0'){
				j--;
			}
			ncount = j - i + 1;
			strncpy(str, str + i, ncount);//这样运行会出现BUG 直接down机，因为这个str接受的形参指针式指向全局区（也就是常量区）内存空间的，该内存空间不能被修改，所以要看主函数传入进来的字符串是分配在什么区
			str[ncount] = '\0';//这个必须加否则后面的128个字节将全部打印出来
			return 0;

			}
			/////////////////////////////////////////////////////////
			main(){
			char *p = "   abcdefffz   ";
			
			getnospacechar(p);//这样执行后整个程序都会崩溃，因为定义的char *p = "   abcdefffz   ";这个指针指向的空间是在内存四区里面的常量区
			该区域只能读，不能写，如果写或者去修改该区域，程序就会崩溃
			printf("%s\n", p);
			}
			
			//////////////////////////////////////////////////////////
			main(){
			buf[1024] = "   abcdefffz   ";
			
			getnospacechar(buf);//这样执行后程序不会被崩溃，因为你是用数组形式定义的常量，这个数组形式定义的东西都是在内存的临时区，所以可以读写。
			printf("%s\n", buf);
			}
			*********************************************************************************/



写一个字符串到已有的内存,二级指针输入应用-------------------------------------------------------------------------------------------------------------------------------

			#include <string.h>
			原型声明：char *strcpy(char* dest, const char *src);
			把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间
			src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。


			char a[20],c[]="i am teacher!";
			strcpy(a,c);
			
			/******************************strcpy应用****************************************
			字符串载入和长度计算接口
			int getMem(char **myp1,int *mylen1,char **myp2,int *mylen2)
			{ 
				char *tmp1=NULL,*tmp2=NULL;
				tmp1= (char *)malloc(100);//在实际应用中，分配内存后记得if一下内存是否为NULL，也就是分配失败。
				strcpy(tmp1,"abcdefg");
				*mylen1=strlen(tmp1);
				*myp1=tmp1;
				tmp2= (char *)malloc(100);//在实际应用中，分配内存后记得if一下内存是否为NULL，也就是分配失败。
				strcpy(tmp2,"1122333444");
				*mylen2=strlen(tmp2);
				*myp2=tmp2;
				
			}
			字符串载入和长度计算接口里面用malloc动态方式申请了内存，所以还要写一个动态释放内存的函数
			int getMen_Free(char **myp)//这个定义为二级指针后，*myp就是获取一级指针的地址
			{
				if(myp==NULL){
					return;
				}
				free(*myp);//释放完指针变量 ，所致的内存空间,这样不仅myp执向的内存空间释放了，而且传递进来的指针也会被释放掉，所以用二级指针来做指针传递时为了让一级指针占用的内存也能释放掉
				*myp=NULL;
			}

			int getMen_Free_1(char *myp)//这个定义为一级级指针后，只能释放myp的内存空间，不能释放*myp，也就是传进来的内存空间，这样传进来的指针就成了野指针
			{
				if(myp==NULL){
					return;
				}
				free(myp);//只释放了myp指向的内存空间，没有释放指针的内存空间，因为在定义指针的时候也会占用4个字节，所以这4个字节没有释放掉，只释放了这4个字节指针所指向的内存空间
				
			}
			
			//////////////////////////////////////////////////////////////////////////////////////
			main(){
			char *p1=NULL,*p2=NULL;
			int len1=0,len2=0;
			getMem(&p1,&len1, &p2,&len2);//获取getmen函数里面分配的字符串地址和字符串长度
			getMen_Free(p1);//*p1不会出现野指针
			getMen_Free(p2);
			
			getMen_Free_1(p1);//*p1会出现野指针
			}

			*********************************************************************************************/
			这个代码有个特殊的地方就是
			int getMen_Free_1(char *myp)
			{
				if(myp==NULL){
					return;
				}
				free(myp);
				myp=NULL; //这样行不行，这样是不行的，因为释放的是栈区的内存空间，如果这个子函数执行完后，栈区空间释放完了，但是主函数的*p1还是没有释放啊
				所以二级指针的好处就是要把主函数里面*p1的地址传进来，然后用子函数去释放掉主函数*p1的内存，因为只有二级指针能接入一级指针，所以这样用
				}



指针数组的应用------------------------------------------------------------------------------------------------------------------------------------
			char *myarray[] = { "aaaaaa", "bbbbbbbb", "cccccccccccc","11" };//数组的每个元素是指针，所以叫指针数组
			sizeof(myarray)//sizeof(myarray)是对整个数组求长度
			sizeof(myarray[0])//是对数组一个元素求长度
			num=sizeof(myarray) / sizeof(myarray[0]);//得出来的就是数组里面有多少段

			printf("%s\n", myarray[i]);//在数组定义成二维数组*myarray[]之后myarray[i]这样就是获取数组元素所指向的字符串位置
			printf("%s\n", *(myarray + i));//这个和上面这个printf是一样的结果,因为数组是指针建议用这种方式打印
			
两个字符串大小比较strcmp的应用-----------------------------------------------------------------------------------------------------------------------------------------	
			#include <string.h>
			extern int strcmp(const char *s1,const char *s2);
			
			当s1<s2时，返回为负数；
			当s1==s2时，返回值= 0；
			当s1>s2时，返回正数。
			特别注意：strcmp(const char *s1,const char * s2)这里面只能比较字符串，即可用于比较两个字符串常量，或比较数组和字符串常量，不能比较数字等其他形式的参数。
			两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\0'为止。如："A"<"B" "a">"A" "computer">"compare"，所以不是比较字符串个数多少，而是比较字符串里面字符的大小


			/**********************************************strcmp排序应用****************************************************
			char *myarray[] = { "aaaaaa", "bbbbbbbb", "cccccccccccc","11" };//数组的每个元素是指针，所以叫指针数组
			int i,j，num;
			
			char *tmp=NULL;
			num=sizeof(myarray) / sizeof(myarray[0]);//sizeof(myarray)是对整个数组求长度，sizeof(myarray[0])是对数组一个元素求长度，得出来的就是数组里面有多少段
			/////////////排序之前//////////
			printf("排序之前\n");
			for (i = 0; i < num; i++){
				printf("%s\n", myarray[i]);//在数组定义成二维数组*myarray[]之后myarray[i]这样就是获取数组的每一行字符串的首地址，如果要获取每一行字符串里面的第几个字符的话，myarray[i]这样是不行的
				printf("%s\n", *(myarray + i));//这个和上面这个printf是一样的结果,因为数组是指针建议用这种方式打印
			}

			/////////////排序//////////
			for (i = 0; i < num; i++){
				for (j = i; j < num; j++){
					if (strcmp(myarray[i], myarray[j]) > 0){
						tmp = myarray[i];//交换的是数组元素，交换的是指针指向的字符串地址
						myarray[i] = myarray[j];
						myarray[j] = tmp;
					}
			


				}
			}
			/////////////排序之后//////////
			printf("排序之后\n");
			for (i = 0; i < num; i++){
				printf("%s\n", myarray[i]);
				printf("%s\n", *(myarray + i));//这个和上面这个printf是一样的结果,因为数组是指针建议用这种方式打印
			}


			******************************************************************************************************************/
			/**************************************用二级指针做形参进行排序的接口封装***************************************
			void myarrayprint(char **myarray,int num){
			int i = 0;
			/////////////排序之前//////////
			printf("排序之前\n");
			for (i = 0; i < num; i++){
			//printf("%s\n", myarray[i]);//在数组定义成二维数组*myarray[]之后myarray[i]这样就是获取数组
			printf("%s\n", *(myarray + i));//这个和上面这个printf是一样的结果,因为数组是指针建议用这种方式打印
				}
			}
			///////////////////////////////二维数组排序接口封装/////////////////////
			void sortmyarray(char **myarray, int num){
			int i, j;
			char *tmp = NULL;
			/////////////排序//////////
			for (i = 0; i < num; i++){
				for (j = i; j < num; j++){
					if (strcmp(myarray[i], myarray[j]) > 0){
						tmp = myarray[i];//交换的是数组元素，交换的是指针指向的字符串地址，并没有将字符串拷来拷去
						myarray[i] = myarray[j];
						myarray[j] = tmp;
						}



					}
				}
			}
			/////////////////////////主函数调用接口//////////////////////////////////////////

			char *myarray[] = { "aaaaaa", "bbbbbbbb", "cccccccccccc","11" };//数组的每个元素是指针，所以叫指针数组
			int i,num;
			num=sizeof(myarray) / sizeof(myarray[0]);//sizeof(myarray)是对整个数组求长度，sizeof(myarray[0])是对数组一个元素求长度
	
			myarrayprint(myarray, num);//指针数组传入二级指针就是这样传入的
			sortmyarray(myarray, num);
			**************************************************************************************************************************/




二级指针做输入的另一种内存模型------------------------------------------------------------------------------------------------------------------------------------
			char myarray[10][30] = { "aaaa", "cccc", "bbbb", "1111" };//定义一个二维数组存放字符串和上面字符串指针有点类似.

			/**********************************************************
			void printarraypoint(char **myarray,int num){  //如果定义的是一个二维数组，而不是指针数组的话 *myarray[] 那么调用该函数程序会崩溃
				int i = 0;
				for (i = 0; i < num; i++){
				printf("%s\n", *(myarray+i));//因为在执行myarray+i这一段的时候，传入char *myarray[]这种的内存模型和传入myarray[10][30]这种的内存模型，指针步长是不一样的。

				}	
			}

			void printarray(char myarray[10][30], int num){ //所以接口函数的形参必须是这样，指针的步长才能同步
			int i = 0;
			for (i = 0; i < num; i++){
				printf("%s\n", *(myarray + i));//这里获取数组字符串的行数方法还是和上面一样
				}		
			}
			
			/////////////////////////////////////////////////////主函数/////////////////////////////////////////////
			void main(){

				printarraypoint(myarray, num);//这种方法是无法执行通过的，说明的这种方式只能实用指针数组char *myarray[] = { "aaaaaa", "bbbbbbbb", "cccccccccccc" };
				printarray(myarray, num);//这样就可以传入二维数组的实参,但是这样有个问题只能传入数组定义的时候固定大小的参数
				}

			********************************************************************************************/





指针数组和二位数组的长度区别------------------------------------------------------------------------------------------------------------------------------------------------
			void main(){
			char array[10][30] = { "aaaaa", "bbbbbb", "ddddddd" };
			char *arrpay[] = {"ccccccccccccc","vvvvvvvvvvvvv","xxx"};
			int a, b, c;
			a = sizeof(array);//这个是计算整个数组的长度10X30=300
			b = sizeof(array[0]);//整个是计算数组一行的长度30
			c = sizeof(array) / sizeof(array[0]);整个是计算数组有好多行 10
			printf("a = %d\nb = %d\nc = %d\n", a, b, c);
			printf("数组指针\n");///////////////////////////二位数组计算和指针数组计算的区别就从这里开始，一定要记住

			a = sizeof(arrpay);//整个是计算指针数组的整个长度12 ，为什么是12，因为{"ccccccccccccc","vvvvvvvvvvvvv","xxx"};这是三个指针指向的地址，也就是一个指针是4字节，所以加起来是12，里面的多少个c多少个v是没有计算进去的，只提取了每个字符串的首地址进行计算，所以算出来是3
			b = sizeof(arrpay[0]);//整个是计算指针数组一个地址的长度
			c = sizeof(arrpay) / sizeof(arrpay[0]);//这个指针数组有3个地址
			printf("a = %d\nb = %d\nc = %d\n", a, b, c);
			system("pause");
			}



用二级指针打造内存模型--------------------------------------------------------------------------------------------------------------------------------------------------------------重点----------------------
			这是一个开口向下的栈
			------------
			| -------  |	申请一个内存指针
			| |	|  |  --------》-------------------------------------------------
			|	   |		|	|	|	|	|	|	|
			|	   |		-------------------------------------------------
			|	   |		   |
			|	   |		   |内存里面的每个指针指向一个内存区域，用来存放字符串或者数据
			|	   |		---------
			|	   |		|	|
			|	   |		---------

			
			p2 = (char **)malloc(sizeof(char *)*num);//这样在sizeof（char *） 在sizeof里面打*是为了让别人知道我分配的这个数组是来存放指针地址的
			p2 = (char **)malloc(400);//如果不写sizeof，直接写分配多少也可以，但是别人看起就很麻烦，虽然结果是一样的，但是不符合人类阅读的习惯，所以建议用上面这种。
			
			p2 = (char **)malloc(sizeof(char *)*num);//分配完成后为什么要(char **)强转，是因为让编译起知道我分配的是一个二级指针，如果不强转编译器会报错，运行的时候说不定会出现什么bug
			/*************************************************************************************************
			void main(){

			char **p2=NULL;
			int num = 5,i=0;
			p2 = (char **)malloc(sizeof(char *)*num);//这里创建的一串内存空间全部是存放指针变量的
			for (i = 0; i < num; i++){
				p2[i] = (char *)malloc(sizeof(char) * 100);//p2[i]就是等于*p2，因为p2是二级指针，所以*p2也是存放地址的变量，p2是存放指针地址的变量，而不是数据地址的变量*p2才是存放数据地址的变量
				sprintf(p2[i], "%d %d %d", i+1, i+1, i+2);

			}
			for (i = 0; i < num; i++){
				printf("%s\n", p2[i]);
			}
			system("pause");
			}
			********************************************************************************************************/
			执行结果就是
			1 1 2
			2 2 3
			3 3 4
			4 4 5
			5 5 6 其实就是往*p2指向的地址写数据，然后可以用**p2将数据取出来，这里使用的是字符串所以，直接printf("%s",*p)就可以了。 
			/********************************************就是**P二级指针的意思***********************************************************
			其实上面的方法就和下面这个是一样的
			int **p1; 	先定义一个二级指针
			int i = 0;
			int z = 50,v=30;
			p1 = (int **)malloc(sizeof(int *) * 5);//给二级指针分配一个存放指针地址的内存，记住该内存是存放指针地址的不是存放数据的
			p1[0] = (int *)malloc(sizeof(int) * 100);//给存放在二级指针内存的指针地址，分配要指定的新内存
			p1[0] = &z;			//然后将新内存指向一个有数据的整形地址，类似*p=&z，然后**p就是取该地址的数据，*p就是取地址
			p1[1] = (int *)malloc(sizeof(int) * 100);
			p1[1] = &v;
			printf("p1[0] = %d\n", *p1++);//打印的是地址1571592
			printf("p1[1] = %d\n", *p1);  //打印的是地址1571580
			printf("p1[0] = %d\n", *p1[0]);//打印的是数据50
			printf("p1[1] = %d\n", *p1[1]);//打印的是数据30
			printf("p1[0] = %d\n", **p1++);//打印的也是数据50
			printf("p1[1] = %d\n", **p1);//打印的也是数据30
				
			证明了*p1和p1[0]结果是一样的，如果要偏移一个地址*p1++或者p1[1]，如果要获取数据就必须是*p1[0]和**p1

			*************************************************************************************************/
			
			/**************************对上面的函数做接口封装******************************************
				char **getmem(int num){ //这样二级指针内存在堆里面分配之后在主函数用一个二级指针接过来就行了。
				char **p2 = NULL;
				int i = 0;
				sortpoint2();
				p2 = (char **)malloc(sizeof(char *)*num);//这里创建的一串内存空间全部是存放指针变量的
				for (i = 0; i < num; i++){
					p2[i] = (char *)malloc(sizeof(char) * 100);//p2[i]就是等于*p2，因为p2是二级指针，所以*p2也是存放地址的变量，p2是存放指针地址的变量，而不是数据地址的变量*p2才是存放数据地址的变量
					sprintf(p2[i], "%d %d %d", i + 1, i + 1, i + 2);
	
				}
				return p2;
				}子函数执行完了，子函数里面的数据会被清空，但是malloc堆里面的数据还在，所以这个时候return p2把二级指针传给主函数的二级指针
			/////////////////////////////////////////////////////////////////////////////
				main（){
				char **p2=NULL;
				p2 = getmem(num);
				/*这样又可以对p2进行正常排序了*/
				}
			*********************************************************************************************/
			这种二级指针内存模型已经做完了，记得要写释放内存函数
			free(p2[i]);//先释放一维的内存，记住申请多少个就一定要释放多少个
			free(p2);//再释放二维的，所以二级指针和一级指针不一样，要执行两次free


多级指针语法提高----------------------------------------------------------------------------------------------------------------------------------------------------
			/*用来接二级指针的形参必须用三级指针 比如char ***p3 */
			/*  *p3存放二级指针地址 
			p3三级指针本身的地址
			**p3获取二级指针的值
			***p3获取二级指针所指向的一级指针的值*/
			void getmems(char ***p3,int num){
			char **tmp = NULL;
			int i = 0;
			tmp = (char **)malloc(sizeof(char *)*num);
			for (i = 0; i < num; i++){
			  tmp[i] = (char *)malloc(sizeof(char) * 100);
			  sprintf(tmp[i], "%d %d %d", i + 1, i + 1, i + 2);
			}
			*p3 = tmp;//将二级指针分配好内存的地址赋值给形参，这样传入进来的二级指针形参就获取了分配的二级指针地址
	
			}

			/*释放三级指针内存*/
			void getmemfree(char ***p3, int num){
			char **tmp = NULL;
			tmp = *p3;//获取传入进来二级指针的地址
			for (int i = 0; i < num; i++){
			free(tmp[i]);//类似*tmp；
			}
			free(tmp);
			}
		//////////////////////////////////////三级指针内存分配与使用/////////////////////////////////////////////	
			void main(){
			char **p2 = NULL;
			int num = 5, i = 0;
	 		getmems(&p2,num);//给二级指针分配内存
			for (i = 0; i < num; i++){
			 printf("%s\n", p2[i]);
			 }
			 getmemfree(&p2,num);//释放二级指针内存
			 system("pause");
			 }	


用数组和指针操作字符串------------------------------------------------------------------------------------------------------------------------------------------------------
			char buf[128] = "abcdefg";
			printf("buf c = %c\n", buf[i]);
			printf("*p c = %c\n", *(p + i));//用指针去字符串数组的每一个元素方式来输出
			//*p 和[]推到过程 其实buf[i]这个是便于人类阅读，*(buf + i)这个便于机器阅读
			//所以不管你是buf[i]还是*(p + i)最后编译器都会翻译成*(buf + i)，所以*(buf + i)这种写法才是真正的写法
			//最后的结论就是*p和[]这两种写法的本质都是一样的

查找相同字符串strstr---------------------------------------------------------------------------------------------------------------------------------------------------------
			extern char *strstr(char *str1, const char *str2);
			返回值：若str2是str1的子串，则返回str2在str1的首次出现的地址；如果str2不是str1的子串，则返回NULL
			/*************************************************************************************************
			char *s=”string1onexxxstring2oneyyy”;
			char *p;
			p=strstr(s,"one");//查找字符串s里面是否有one，如果搜索到第一个one那么久把该one的第一个o地址赋值给p
			if(p!=NULL)
 			   printf(“%s”,p);
			else
   			printf("notfound\n");

			找到的是onexxxstring2oneyyy   //输出的结果就是p指向第一个o的位置向后所有的偏移全部打印出来，o前面的全部取消


字符串内存分配malloc问题注意---------------------------------------------------------------------------------------------------------------------------------------------
			char *buf = (char *)malloc(strlen("ab"));//分配了两个内存
			strcpy(buf,"ab");//执行该程序就死机，为什么因为我们是给字符串分配内存，不是给整数浮点数分配内存
			字符串分配内存有个特点就是数组最后会被系统自动添加一个\0，所以这个\0要多占用一个字节
			char *buf = (char *)malloc(strlen("ab")+1);//所以在给字符串分配的时候要多加个1,这样就可以给\0存放空间
			strcpy(buf,"ab");//再执行该程序就正常了。


数组地址偏移的步长---------------------------------------------------------------------------------------------------------------------------
			int a[10]；
			printf("地址偏移= ", &a+1);//注意，&a+1相当于整个数组长度加1，也就是&a+1之后，就是a[10]
			printf("地址偏移= ", a+1);//注意a+1是a的地址向后移动一个长度，也就是a+1就是a[1]，a+2就是a[2]
			所以在取数组地址的时候&a和a是有很大的却别的，一定要记住
			比如一个二维数组 int a[5][10]
			a+1就相当于一维数组的&a+1也就是a向后偏移10个数组单位因为在二维数组里面a+1不是像一维数组那样首地址+1，而是直接跳到第二行的首地址，所以要跳到第二行的首地址，就必须把第一行偏移完。也就是10*4=40个字节
			所以二维数组中数组a其实是一个数组指针

typedef和define的区别----------------------------------------------------------------------------------------------------------------------------------------------------
			define num 5 //这种做法是用num代替5这个数字，在使用中程序员便于识别
			typedef char* PCHAR;  //typedef是为了让PCHAR替代char，也是为了程序员方便识别，这点和define是一样的
			PCHAR pa, pb;  

			typedef int Myarraytyped[5]; //但是在定义数组中就和define有不一样的地方，把数组定义成类型typedef这个字符很重要 ，是它决定了该数组是否可以作为类型还是作为普通数组
			Myarraytyped myarray;	//typedef将数组定义成类型后，就可以用数组来定义一个变量，这种用法以前从来没用到过，但是数组类型确实有这个功能 也就相当于int myarray[5]；

			Myarraytyped *mypoint;//typedef int Myarraytyped这样的好处在于可以将数组定义成指针
			int a[5];
			mypoint = &a;//然后这个数组指针可以存放其他数组的首地址
			/*我们通过数组指针的方式来操作a[5]这个内存*/
			for (int i = 0; i < 5; i++){
				(*mypoint)[i] = i + 1; //这样就相当于a[i]=i+1；和上面这个myarray[i] = i + 1;一样,这样做是不是很别扭，对它就是这样装逼没办法

			}
			for (int i = 0; i < 5; i++){
				printf("mypoint addr = %d\n", mypoint[i]);//这样是取每段数组的地址，但是地址是按照5*4=20个字节偏移的，因为这个指针最先定义的就是typedef int Myarraytyped[5]一个地址存放5个元素的首地址
				 printf("mypoint = %d\n", (*mypoint)[i]);//这样是取每段数组地址上存放的值，妈卖批和上面那个一样的，哎  老子
			}
			
			/************************用数组定义指针的方法*************************************************
			void arraypoint(){
			typedef int Myarr[5];//定义一个数组类型
			typedef int(*parrary)[5];//这样就定义了一个数组指针类型，而不是上面的数组类型,可以这样理解；(*parrary)这是一个指针,然后这个指针可以存放一个[5]这么大的数组首地址,或者是这个(*parrary)指针指向一个[5]这么大数组的地址，都一样
			parrary myp;//用这个(*parrary)[5];类型就可以定义一个变量；然后就可以使用这个变量了。而且注意这个myp是个指针，但是为什么myp前面不加*呢，因为定义它的这个数组指针在上一行代码的时候已经加*了，所以这里就直接定义就是了不用加*

			int b[5];
			myp = &b;//这里传地址就不是前面那种 int *p=b方法了，因为这里取得地址是取数组本身的地址&b，然后myp+1就直接偏移5个数组，所以这种方法指针&b+1的步长和前面b+1这种步长是不一样的
			for (int i = 0; i < 5; i++){
				(*myp)[i] = i + 1;//写数据方式和上面一样
			}

			for (int i = 0; i < 5; i++){
				printf("myp = %d\n", (*myp)[i]);//打印也是一样
				}
			}
			***************************************************************************/
			根据上面代码写出的结论证明了typedef int Myarraytyped[5];这种定义方法可以定义数组typedef int Myarraytyped[5];还可以定义Myarraytyped *mypoint;指针
						    typedef int(*parrary)[5];如果用这种方法就只能定义指针parrary myp;无法用这个方法定义数组，看自己怎么选择咯



多维数组做函数参数的退化过程------------------------------------------------------------------------------------------------------------------
			如果是一维数组那么退化过程为 int a[10] ======》int a[] =====》int *a;
			用于函数参数就是  void array(int a[10]);//初级水平阶段
					  void array(int a[]);//中极水平阶段
					  void array(int *a);//高级水平阶段
			如果是二维数组那么退化过程为 char buf[10][30] ===============>char buf[][30] ===================>char (*buf)[30];  //char buf[][30]第一个中括号可以不写，第二个中括号必须要写数字，因为这个数字决定了指针在内存一次偏移多长
			
			用于函数参数就是 array(char buf[10][30] );//初级水平阶段
					 array(char buf[][30] );//中极水平阶段
					 array(char (*buf)[30] );//高级水平阶段

			

			/***************************************一维和二维数组做函数参数应用****************************

			void printarray1(int a[10]){
				printf("printarray1 = %d\n", a[0]);//不管一维数组使用什么形参，使用一维数组的本质都是一样的
			}
			void printarray2(int a[]){
				printf("printarray2 = %d\n", a[0]);//不管一维数组使用什么形参，使用一维数组的本质都是一样的
			}
			void printarray3(int *a){
				printf("printarray3 = %d\n", a[0]);//不管一维数组使用什么形参，使用一维数组的本质都是一样的
			}
			void print2array1(int a[10][30]){
				printf("print2array1 = %d\n", *((*(a+1))+1));//不管二维数组使用什么形参，使用二维数组的本质都是一样的
				printf("print2array1 a[][] = %d\n", a[1][1]);//不管二维数组使用什么形参，使用二维数组的本质都是一样的
			}
			void print2array2(int a[][30]){
				printf("print2array2 = %d\n", *((*(a + 1)) + 1));//不管二维数组使用什么形参，使用二维数组的本质都是一样的
				printf("print2array2 a[][]= %d\n", a[1][1]);//不管二维数组使用什么形参，使用二维数组的本质都是一样的
			}
			void print2array3(int (*a)[30]){
				printf("print2array3 = %d\n", *((*(a + 1)) + 1));//不管二维数组使用什么形参，使用二维数组的本质都是一样的
				printf("print2array3 a[][] = %d\n", a[1][1]);//不管二维数组使用什么形参，使用二维数组的本质都是一样的
			}


			//////////////////////////////////////////////////////////////////////////////////////
			void main()
			{   
			int yiwei[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
			int erwei[10][30];
			erwei[0][1] = 20;
			erwei[1][1] = 25;
			printarray1(yiwei);
			printarray2(yiwei);
			printarray3(yiwei);
			print2array1(erwei);
			print2array2(erwei);
			print2array3(erwei);

			system("pause");
			}
			*******************************************************************************************************/
			不管一维数组或者二维数组在子函数里面用什么形参，在子函数取形参数据都是和普通一维数组和二维数组的用法一样的，因为不管几维数组，在内存中都是线性排列的。




用一级指针使用多维数组----------------------------------------------------------------------------------------------------------------------------------------------------------------

			/*证明一下多维数组的线性存储*/
			void printarray(int *p,int num){ //用一级指针接受二维数组
				for (int i = 0; i < num; i++){
				printf("array = %d\n", p[i]);//用一级指针打印二维数组
				}
			}

			///////////////////////////////////////////////////////////////////////////////
			void main(){
			int a[5][10];
			int tmp=0;
			for (int i = 0; i < 5; i++){
				for (int j = 0; j < 10; j++){
				a[i][j] = tmp++;
				}
			}
			printarray((int *)a,50);//这里要用(int *)将二维数组强转成一维，因为printarray形参是一维。
			system("pause");

			}
			
			多维数组做函数参数一般情况下只用到二维，如果是三维的a[1][2][3]指针做函数参数是无法表达了。
			三维数组就是我们程序员自己取得名字，没有任何意义，所以没必要做三维的。

			如果有人在函数形参里面这样装逼 array(char ***d)；//这就是获取二维数组的地址，而不是三维数组
						如果   array（char *******d）；//如果有超过三级以上的指针，这绝对不代表要使用几个内存或者获取几维数组，绝对是其他用法，数组只能做到二维。


用二级指针做二维数组形参----------------------------------------------------------------------------------------------------------------------------------------------------------------------
			
			array(char *p[3]);//这三种是一样的
			array(char *p[]);//这三种是一样的
			array(char **p);//这三种是一样的

			

